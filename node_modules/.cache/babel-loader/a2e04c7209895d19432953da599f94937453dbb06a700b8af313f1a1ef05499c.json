{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from \"react\";\n// Importa el tipo Task desde un módulo de interfaces.\n\nconst useSortTasks = tasks => {\n  _s();\n  const [sortedBy, setSortedBy] = useState(\"\"); // Estado para almacenar el criterio de ordenamiento seleccionado.\n\n  const [sortedTasks, setSortedTasks] = useState(tasks); // Estado para almacenar las tareas ordenadas.\n\n  useEffect(() => {\n    // Función para ordenar por fecha (ascendente o descendente).\n    const sortByDate = order => {\n      const toMilliseconds = date => Date.parse(date);\n      const tasksCopy = [...tasks];\n      const sorted = tasksCopy.sort((task1, task2) => {\n        const date1 = toMilliseconds(task1.date);\n        const date2 = toMilliseconds(task2.date);\n        if (date1 < date2) {\n          return -1;\n        }\n        if (date1 > date2) {\n          return 1;\n        }\n        return 0;\n      });\n      if (order === \"min-date\") {\n        return sorted;\n      }\n      if (order === \"max-date\") {\n        return sorted.reverse();\n      }\n      return tasks; // Si el orden no es válido, devuelve las tareas sin cambios.\n    };\n\n    // Función para ordenar por estado de completado (completado primero o no completado primero).\n    const sortByCompletedStatus = completed => {\n      const tasksCopy = [...tasks];\n      const sorted = tasksCopy.sort(task1 => {\n        if (task1.completed) {\n          return -1;\n        }\n        return 0;\n      });\n      if (completed) {\n        return sorted;\n      }\n      if (!completed) {\n        return sorted.reverse();\n      }\n      return tasks; // Si el orden no es válido, devuelve las tareas sin cambios.\n    };\n\n    // Verifica el criterio de ordenamiento seleccionado y actualiza las tareas ordenadas en consecuencia.\n    if (sortedBy === \"min-date\" || sortedBy === \"max-date\") {\n      setSortedTasks(sortByDate(sortedBy));\n    }\n    if (sortedBy === \"\" || sortedBy === \"order-added\") {\n      setSortedTasks(tasks);\n    }\n    if (sortedBy === \"completed-first\") {\n      setSortedTasks(sortByCompletedStatus(true));\n    }\n    if (sortedBy === \"uncompleted-first\") {\n      setSortedTasks(sortByCompletedStatus(false));\n    }\n  }, [sortedBy, tasks]); // El efecto se ejecuta cuando cambia sortedBy o tasks.\n\n  // Devuelve el criterio de ordenamiento actual, la función para cambiarlo y las tareas ordenadas.\n  return {\n    sortedBy,\n    setSortedBy,\n    sortedTasks\n  };\n};\n_s(useSortTasks, \"7NAV0cBwirKTnHXlnNvI/g1df1c=\");\nexport default useSortTasks;","map":{"version":3,"names":["useState","useEffect","useSortTasks","tasks","sortedBy","setSortedBy","sortedTasks","setSortedTasks","sortByDate","order","toMilliseconds","date","Date","parse","tasksCopy","sorted","sort","task1","task2","date1","date2","reverse","sortByCompletedStatus","completed"],"sources":["C:/Users/shelsyn/mio/Gestor-p/src/components/hooks/useSortTasks.tsx"],"sourcesContent":["import { useState, useEffect } from \"react\";\r\nimport { Task } from \"../../interfaces\"; // Importa el tipo Task desde un módulo de interfaces.\r\n\r\nconst useSortTasks = (tasks: Task[]) => {\r\n  const [sortedBy, setSortedBy] = useState<string>(\"\"); // Estado para almacenar el criterio de ordenamiento seleccionado.\r\n\r\n  const [sortedTasks, setSortedTasks] = useState<Task[]>(tasks); // Estado para almacenar las tareas ordenadas.\r\n\r\n  useEffect(() => {\r\n    // Función para ordenar por fecha (ascendente o descendente).\r\n    const sortByDate = (order: \"max-date\" | \"min-date\"): Task[] => {\r\n      const toMilliseconds = (date: string) => Date.parse(date);\r\n      const tasksCopy = [...tasks];\r\n      const sorted = tasksCopy.sort((task1, task2) => {\r\n        const date1 = toMilliseconds(task1.date);\r\n        const date2 = toMilliseconds(task2.date);\r\n\r\n        if (date1 < date2) {\r\n          return -1;\r\n        }\r\n\r\n        if (date1 > date2) {\r\n          return 1;\r\n        }\r\n\r\n        return 0;\r\n      });\r\n\r\n      if (order === \"min-date\") {\r\n        return sorted;\r\n      }\r\n\r\n      if (order === \"max-date\") {\r\n        return sorted.reverse();\r\n      }\r\n\r\n      return tasks; // Si el orden no es válido, devuelve las tareas sin cambios.\r\n    };\r\n\r\n    // Función para ordenar por estado de completado (completado primero o no completado primero).\r\n    const sortByCompletedStatus = (completed: boolean): Task[] => {\r\n      const tasksCopy = [...tasks];\r\n      const sorted = tasksCopy.sort((task1) => {\r\n        if (task1.completed) {\r\n          return -1;\r\n        }\r\n        return 0;\r\n      });\r\n\r\n      if (completed) {\r\n        return sorted;\r\n      }\r\n\r\n      if (!completed) {\r\n        return sorted.reverse();\r\n      }\r\n\r\n      return tasks; // Si el orden no es válido, devuelve las tareas sin cambios.\r\n    };\r\n\r\n    // Verifica el criterio de ordenamiento seleccionado y actualiza las tareas ordenadas en consecuencia.\r\n    if (sortedBy === \"min-date\" || sortedBy === \"max-date\") {\r\n      setSortedTasks(sortByDate(sortedBy));\r\n    }\r\n    if (sortedBy === \"\" || sortedBy === \"order-added\") {\r\n      setSortedTasks(tasks);\r\n    }\r\n    if (sortedBy === \"completed-first\") {\r\n      setSortedTasks(sortByCompletedStatus(true));\r\n    }\r\n    if (sortedBy === \"uncompleted-first\") {\r\n      setSortedTasks(sortByCompletedStatus(false));\r\n    }\r\n  }, [sortedBy, tasks]); // El efecto se ejecuta cuando cambia sortedBy o tasks.\r\n\r\n  // Devuelve el criterio de ordenamiento actual, la función para cambiarlo y las tareas ordenadas.\r\n  return { sortedBy, setSortedBy, sortedTasks };\r\n};\r\n\r\nexport default useSortTasks;\r\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AACF;;AAEzC,MAAMC,YAAY,GAAIC,KAAa,IAAK;EAAA;EACtC,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAGL,QAAQ,CAAS,EAAE,CAAC,CAAC,CAAC;;EAEtD,MAAM,CAACM,WAAW,EAAEC,cAAc,CAAC,GAAGP,QAAQ,CAASG,KAAK,CAAC,CAAC,CAAC;;EAE/DF,SAAS,CAAC,MAAM;IACd;IACA,MAAMO,UAAU,GAAIC,KAA8B,IAAa;MAC7D,MAAMC,cAAc,GAAIC,IAAY,IAAKC,IAAI,CAACC,KAAK,CAACF,IAAI,CAAC;MACzD,MAAMG,SAAS,GAAG,CAAC,GAAGX,KAAK,CAAC;MAC5B,MAAMY,MAAM,GAAGD,SAAS,CAACE,IAAI,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAK;QAC9C,MAAMC,KAAK,GAAGT,cAAc,CAACO,KAAK,CAACN,IAAI,CAAC;QACxC,MAAMS,KAAK,GAAGV,cAAc,CAACQ,KAAK,CAACP,IAAI,CAAC;QAExC,IAAIQ,KAAK,GAAGC,KAAK,EAAE;UACjB,OAAO,CAAC,CAAC;QACX;QAEA,IAAID,KAAK,GAAGC,KAAK,EAAE;UACjB,OAAO,CAAC;QACV;QAEA,OAAO,CAAC;MACV,CAAC,CAAC;MAEF,IAAIX,KAAK,KAAK,UAAU,EAAE;QACxB,OAAOM,MAAM;MACf;MAEA,IAAIN,KAAK,KAAK,UAAU,EAAE;QACxB,OAAOM,MAAM,CAACM,OAAO,EAAE;MACzB;MAEA,OAAOlB,KAAK,CAAC,CAAC;IAChB,CAAC;;IAED;IACA,MAAMmB,qBAAqB,GAAIC,SAAkB,IAAa;MAC5D,MAAMT,SAAS,GAAG,CAAC,GAAGX,KAAK,CAAC;MAC5B,MAAMY,MAAM,GAAGD,SAAS,CAACE,IAAI,CAAEC,KAAK,IAAK;QACvC,IAAIA,KAAK,CAACM,SAAS,EAAE;UACnB,OAAO,CAAC,CAAC;QACX;QACA,OAAO,CAAC;MACV,CAAC,CAAC;MAEF,IAAIA,SAAS,EAAE;QACb,OAAOR,MAAM;MACf;MAEA,IAAI,CAACQ,SAAS,EAAE;QACd,OAAOR,MAAM,CAACM,OAAO,EAAE;MACzB;MAEA,OAAOlB,KAAK,CAAC,CAAC;IAChB,CAAC;;IAED;IACA,IAAIC,QAAQ,KAAK,UAAU,IAAIA,QAAQ,KAAK,UAAU,EAAE;MACtDG,cAAc,CAACC,UAAU,CAACJ,QAAQ,CAAC,CAAC;IACtC;IACA,IAAIA,QAAQ,KAAK,EAAE,IAAIA,QAAQ,KAAK,aAAa,EAAE;MACjDG,cAAc,CAACJ,KAAK,CAAC;IACvB;IACA,IAAIC,QAAQ,KAAK,iBAAiB,EAAE;MAClCG,cAAc,CAACe,qBAAqB,CAAC,IAAI,CAAC,CAAC;IAC7C;IACA,IAAIlB,QAAQ,KAAK,mBAAmB,EAAE;MACpCG,cAAc,CAACe,qBAAqB,CAAC,KAAK,CAAC,CAAC;IAC9C;EACF,CAAC,EAAE,CAAClB,QAAQ,EAAED,KAAK,CAAC,CAAC,CAAC,CAAC;;EAEvB;EACA,OAAO;IAAEC,QAAQ;IAAEC,WAAW;IAAEC;EAAY,CAAC;AAC/C,CAAC;AAAC,GA1EIJ,YAAY;AA4ElB,eAAeA,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}